import { AST_NODE_TYPES } from '@typescript-eslint/types';

export enum VulnerabilitySeverity {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
  INFO = 'info'
}

export enum VulnerabilityCategory {
  AUTH = 'authentication',
  AUTHORIZATION = 'authorization',
  INJECTION = 'injection',
  XSS = 'cross_site_scripting',
  CSRF = 'cross_site_request_forgery',
  SECRETS = 'sensitive_data_exposure',
  CONFIG = 'security_misconfiguration',
  RLS = 'row_level_security',
  INPUT_VALIDATION = 'input_validation',
  LOGGING = 'security_logging',
  CRYPTO = 'cryptographic_issues'
}

export interface SecurityFinding {
  id: string;
  severity: VulnerabilitySeverity;
  category: VulnerabilityCategory;
  cweId?: string;
  title: string;
  description: string;
  filePath: string;
  lineStart: number;
  lineEnd: number;
  columnStart: number;
  columnEnd: number;
  code: string;
  remediation: string;
  examples: {
    vulnerable: string;
    secure: string;
  };
  confidence: number; // 0.0 to 1.0
  isFalsePositive: boolean;
  detectedAt: Date;
}

export interface VulnerabilityRule {
  id: string;
  name: string;
  description: string;
  category: VulnerabilityCategory;
  severity: VulnerabilitySeverity;
  cweId?: string;
  owaspCategory?: string;
  pattern: {
    type: 'ast' | 'regex' | 'semantic';
    matcher: any;
  };
  remediation: string;
  examples: {
    vulnerable: string;
    secure: string;
  };
  enabled: boolean;
}

export class VulnerabilityDatabase {
  private rules: Map<string, VulnerabilityRule> = new Map();
  private cweMapping: Map<string, string> = new Map();

  constructor() {
    this.initializeRules();
    this.initializeCWEMapping();
  }

  private initializeRules(): void {
    // SQL Injection Rules
    this.addRule({
      id: 'sql-injection-template-literal',
      name: 'SQL Injection via Template Literals',
      description: 'Direct user input in SQL template literals can lead to SQL injection',
      category: VulnerabilityCategory.INJECTION,
      severity: VulnerabilitySeverity.HIGH,
      cweId: 'CWE-89',
      owaspCategory: 'A03:2021 - Injection',
      pattern: {
        type: 'ast',
        matcher: {
          type: AST_NODE_TYPES.TemplateLiteral,
          hasUserInput: true,
          context: 'sql'
        }
      },
      remediation: 'Use parameterized queries or prepared statements instead of string concatenation',
      examples: {
        vulnerable: 'const query = `SELECT * FROM users WHERE id = ${userId}`;',
        secure: 'const query = db.prepare("SELECT * FROM users WHERE id = ?").get(userId);'
      },
      enabled: true
    });

    // Direct Database Access
    this.addRule({
      id: 'direct-db-access-without-auth',
      name: 'Direct Database Access Without Authentication',
      description: 'Database client created without authentication context',
      category: VulnerabilityCategory.AUTH,
      severity: VulnerabilitySeverity.CRITICAL,
      cweId: 'CWE-306',
      owaspCategory: 'A07:2021 - Identification and Authentication Failures',
      pattern: {
        type: 'semantic',
        matcher: {
          functionCalls: ['drizzle', 'createClient', 'new Pool'],
          missingAuth: true
        }
      },
      remediation: 'Use authenticated database clients like getOrgDatabaseWithAuth()',
      examples: {
        vulnerable: 'const db = drizzle(connectionString);',
        secure: 'const db = await getOrgDatabaseWithAuth();'
      },
      enabled: true
    });

    // Hardcoded Secrets
    this.addRule({
      id: 'hardcoded-secrets',
      name: 'Hardcoded Secrets',
      description: 'Hardcoded credentials or API keys detected',
      category: VulnerabilityCategory.SECRETS,
      severity: VulnerabilitySeverity.CRITICAL,
      cweId: 'CWE-798',
      owaspCategory: 'A07:2021 - Identification and Authentication Failures',
      pattern: {
        type: 'regex',
        matcher: /(?:password|secret|key|token)\s*[=:]\s*['"][^'"]{8,}['"]/i
      },
      remediation: 'Use environment variables or secure secret management',
      examples: {
        vulnerable: 'const apiKey = "sk-1234567890abcdef";',
        secure: 'const apiKey = process.env.API_KEY;'
      },
      enabled: true
    });

    // Missing Auth Checks
    this.addRule({
      id: 'missing-auth-api-route',
      name: 'API Route Missing Authentication',
      description: 'API route handler does not check authentication',
      category: VulnerabilityCategory.AUTH,
      severity: VulnerabilitySeverity.HIGH,
      cweId: 'CWE-306',
      owaspCategory: 'A01:2021 - Broken Access Control',
      pattern: {
        type: 'semantic',
        matcher: {
          isApiRoute: true,
          missingAuthCheck: true
        }
      },
      remediation: 'Add authentication check using requireAuthWithTenant() or similar',
      examples: {
        vulnerable: 'export async function GET() { const data = await db.select(); }',
        secure: 'export async function GET() { const { user } = await requireAuthWithTenant(); }'
      },
      enabled: true
    });

    // XSS Vulnerabilities
    this.addRule({
      id: 'xss-dangerouslysetinnerhtml',
      name: 'XSS via dangerouslySetInnerHTML',
      description: 'Unsanitized user input in dangerouslySetInnerHTML',
      category: VulnerabilityCategory.XSS,
      severity: VulnerabilitySeverity.HIGH,
      cweId: 'CWE-79',
      owaspCategory: 'A03:2021 - Injection',
      pattern: {
        type: 'ast',
        matcher: {
          property: 'dangerouslySetInnerHTML',
          hasUserInput: true
        }
      },
      remediation: 'Sanitize user input using DOMPurify or similar library',
      examples: {
        vulnerable: '<div dangerouslySetInnerHTML={{__html: userContent}} />',
        secure: '<div dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(userContent)}} />'
      },
      enabled: true
    });

    // RLS Bypass
    this.addRule({
      id: 'rls-bypass-direct-client',
      name: 'RLS Bypass via Direct Client',
      description: 'Direct database client bypasses Row Level Security',
      category: VulnerabilityCategory.RLS,
      severity: VulnerabilitySeverity.CRITICAL,
      cweId: 'CWE-284',
      owaspCategory: 'A01:2021 - Broken Access Control',
      pattern: {
        type: 'semantic',
        matcher: {
          directClientUsage: true,
          bypassesRLS: true
        }
      },
      remediation: 'Use RLS-enabled database clients or add manual organization filtering',
      examples: {
        vulnerable: 'const client = new Client(); client.query("SELECT * FROM users");',
        secure: 'const db = await getSupabaseRLS(); db.from("users").select();'
      },
      enabled: true
    });

    // Hardcoded Organization IDs
    this.addRule({
      id: 'hardcoded-org-id',
      name: 'Hardcoded Organization ID',
      description: 'Hardcoded organization ID breaks multi-tenancy',
      category: VulnerabilityCategory.RLS,
      severity: VulnerabilitySeverity.MEDIUM,
      cweId: 'CWE-284',
      owaspCategory: 'A01:2021 - Broken Access Control',
      pattern: {
        type: 'regex',
        matcher: /(?:org|organization|tenant)(?:Id|Slug)\s*[=:]\s*['"][^'"]+['"]/i
      },
      remediation: 'Use dynamic organization ID from authentication context',
      examples: {
        vulnerable: 'const orgId = "acme-corp";',
        secure: 'const { orgSlug } = await requireAuthWithTenant();'
      },
      enabled: true
    });

    // Unvalidated Input
    this.addRule({
      id: 'unvalidated-user-input',
      name: 'Unvalidated User Input',
      description: 'User input used without validation',
      category: VulnerabilityCategory.INPUT_VALIDATION,
      severity: VulnerabilitySeverity.MEDIUM,
      cweId: 'CWE-20',
      owaspCategory: 'A03:2021 - Injection',
      pattern: {
        type: 'semantic',
        matcher: {
          userInputSource: ['req.body', 'searchParams', 'params'],
          noValidation: true
        }
      },
      remediation: 'Validate and sanitize all user input using Zod or similar validation library',
      examples: {
        vulnerable: 'const userId = searchParams.get("id"); db.query(userId);',
        secure: 'const userId = z.string().uuid().parse(searchParams.get("id"));'
      },
      enabled: true
    });
  }

  private initializeCWEMapping(): void {
    this.cweMapping.set('CWE-79', 'Cross-site Scripting (XSS)');
    this.cweMapping.set('CWE-89', 'SQL Injection');
    this.cweMapping.set('CWE-20', 'Improper Input Validation');
    this.cweMapping.set('CWE-284', 'Improper Access Control');
    this.cweMapping.set('CWE-306', 'Missing Authentication for Critical Function');
    this.cweMapping.set('CWE-798', 'Use of Hard-coded Credentials');
    this.cweMapping.set('CWE-352', 'Cross-Site Request Forgery (CSRF)');
    this.cweMapping.set('CWE-311', 'Missing Encryption of Sensitive Data');
    this.cweMapping.set('CWE-209', 'Information Exposure Through Error Messages');
    this.cweMapping.set('CWE-532', 'Information Exposure Through Log Files');
  }

  private addRule(rule: VulnerabilityRule): void {
    this.rules.set(rule.id, rule);
  }

  public getRule(ruleId: string): VulnerabilityRule | undefined {
    return this.rules.get(ruleId);
  }

  public getAllRules(): VulnerabilityRule[] {
    return Array.from(this.rules.values());
  }

  public getRulesByCategory(category: VulnerabilityCategory): VulnerabilityRule[] {
    return Array.from(this.rules.values()).filter(rule => rule.category === category);
  }

  public getRulesBySeverity(severity: VulnerabilitySeverity): VulnerabilityRule[] {
    return Array.from(this.rules.values()).filter(rule => rule.severity === severity);
  }

  public getCWEDescription(cweId: string): string | undefined {
    return this.cweMapping.get(cweId);
  }

  public createFinding(
    ruleId: string,
    filePath: string,
    lineStart: number,
    lineEnd: number,
    columnStart: number,
    columnEnd: number,
    code: string,
    confidence: number = 1.0
  ): SecurityFinding | null {
    const rule = this.getRule(ruleId);
    if (!rule) {
      return null;
    }

    return {
      id: `${ruleId}-${filePath}-${lineStart}-${Date.now()}`,
      severity: rule.severity,
      category: rule.category,
      cweId: rule.cweId,
      title: rule.name,
      description: rule.description,
      filePath,
      lineStart,
      lineEnd,
      columnStart,
      columnEnd,
      code,
      remediation: rule.remediation,
      examples: rule.examples,
      confidence,
      isFalsePositive: false,
      detectedAt: new Date()
    };
  }

  public categorizeFindings(findings: SecurityFinding[]): Map<VulnerabilityCategory, SecurityFinding[]> {
    const categorized = new Map<VulnerabilityCategory, SecurityFinding[]>();
    
    for (const finding of findings) {
      const existing = categorized.get(finding.category) || [];
      existing.push(finding);
      categorized.set(finding.category, existing);
    }
    
    return categorized;
  }

  public prioritizeFindings(findings: SecurityFinding[]): SecurityFinding[] {
    const severityOrder = {
      [VulnerabilitySeverity.CRITICAL]: 0,
      [VulnerabilitySeverity.HIGH]: 1,
      [VulnerabilitySeverity.MEDIUM]: 2,
      [VulnerabilitySeverity.LOW]: 3,
      [VulnerabilitySeverity.INFO]: 4
    };

    return findings.sort((a, b) => {
      const severityDiff = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityDiff !== 0) return severityDiff;
      
      // Secondary sort by confidence (higher confidence first)
      return b.confidence - a.confidence;
    });
  }

  public generateReport(findings: SecurityFinding[]): {
    summary: {
      total: number;
      bySeverity: Record<VulnerabilitySeverity, number>;
      byCategory: Record<VulnerabilityCategory, number>;
    };
    criticalFindings: SecurityFinding[];
    recommendations: string[];
  } {
    const bySeverity = {} as Record<VulnerabilitySeverity, number>;
    const byCategory = {} as Record<VulnerabilityCategory, number>;

    // Initialize counters
    Object.values(VulnerabilitySeverity).forEach(severity => {
      bySeverity[severity] = 0;
    });
    Object.values(VulnerabilityCategory).forEach(category => {
      byCategory[category] = 0;
    });

    // Count findings
    findings.forEach(finding => {
      bySeverity[finding.severity]++;
      byCategory[finding.category]++;
    });

    const criticalFindings = findings.filter(f => 
      f.severity === VulnerabilitySeverity.CRITICAL || 
      f.severity === VulnerabilitySeverity.HIGH
    );

    const recommendations = this.generateRecommendations(findings);

    return {
      summary: {
        total: findings.length,
        bySeverity,
        byCategory
      },
      criticalFindings,
      recommendations
    };
  }

  private generateRecommendations(findings: SecurityFinding[]): string[] {
    const recommendations: string[] = [];
    const categories = new Set(findings.map(f => f.category));

    if (categories.has(VulnerabilityCategory.AUTH)) {
      recommendations.push('Implement comprehensive authentication checks on all API routes');
    }
    if (categories.has(VulnerabilityCategory.RLS)) {
      recommendations.push('Review database access patterns to ensure proper tenant isolation');
    }
    if (categories.has(VulnerabilityCategory.INJECTION)) {
      recommendations.push('Use parameterized queries and input validation for all database operations');
    }
    if (categories.has(VulnerabilityCategory.SECRETS)) {
      recommendations.push('Move all credentials to environment variables or secure secret management');
    }
    if (categories.has(VulnerabilityCategory.XSS)) {
      recommendations.push('Sanitize all user input before rendering in the browser');
    }

    return recommendations;
  }
}

export const vulnerabilityDatabase = new VulnerabilityDatabase();